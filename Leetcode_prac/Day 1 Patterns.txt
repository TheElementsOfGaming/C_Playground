Day 1 Patterns: 

1. The "Filter" (Fast & Slow)

Pattern: One pointer scans (i), one pointer writes (k). Problem: Move Zeroes
C++

void moveZeroes(vector<int>& nums) {
    int k = 0; // The Write Pointer
    
    // Step 1: Filter non-zeroes to the front
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 0) {
            nums[k] = nums[i];
            k++;
        }
    }
    
    // Step 2: Fill the remaining "tail" with zeroes
    while (k < nums.size()) {
        nums[k] = 0;
        k++;
    }
}

2. The "De-Duplicator" (Look-Back)

Pattern: Compare the current element to what was written N steps ago. Problem: Remove Duplicates (Allowing at most 2)
C++

int removeDuplicates(vector<int>& nums) {
    if (nums.size() <= 2) return nums.size();

    int k = 2; // Start at 2 because first two are always "safe"
    for (int i = 2; i < nums.size(); i++) {
        // Look back 2 spots from where we are writing
        if (nums[i] != nums[k - 2]) {
            nums[k] = nums[i];
            k++;
        }
    }
    return k;
}

3. The "Swapper" (Opposite Ends)

Pattern: Pointers start at edges and "meet in the middle." Problem: Reverse a String
C++

void reverseString(vector<char>& s) {
    int left = 0;
    int right = s.size() - 1;

    while (left < right) {
        // Standard swap
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;

        // Move inward
        left++;
        right--;
    }
}

This is a great addition because it marks your transition from Two-Pointer patterns to Greedy/Voting patterns.

Here is the updated section for your printable cheat sheet. I‚Äôve titled this one "The King of the Hill" pattern to help the logic stick.
4. The Voting Pattern (Boyer-Moore)

Scenario: Finding an element that appears more than half the time (>n/2). Key Insight: If you pair up different elements and "cancel" them out, the majority element is guaranteed to be the one left over.
üìù The C++ Template
C++

int majorityElement(vector<int>& nums) {
    int candidate = 0;
    int count = 0;

    for (int x : nums) {
        // Phase 1: If power is depleted, pick a new candidate
        if (count == 0) {
            candidate = x;
        }

        // Phase 2: Update the candidate's power (count)
        if (x == candidate) {
            count++; // Same army: gain power
        } else {
            count--; // Enemy army: both lose 1 solider
        }
    }

    return candidate; // The "last soldier standing"
}

‚ö†Ô∏è Common Pitfall: Variable Shadowing

In an interview, do not write int candidate = x; inside the if block.

    Bad: if (count == 0) { int candidate = x; } (Creates a temporary variable that vanishes).

    Good: if (count == 0) { candidate = x; } (Updates the variable you created at the top).

How to use these templates:

    Identify the goal: Am I removing things? (Filter). Am I reordering? (Swapper). Am I cleaning a sorted list? (De-Duplicator).

    Sketch the pointers: On paper, draw i and k (or left and right).

    Check the "Stop" condition: Is it when the loop ends (i < size) or when pointers meet (left < right)?

5. The Triple Reverse

class Solution {
public:
    // The trusty Two-Pointer Swap Function
    void reverse(vector<int>& nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }

    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        // Handle cases where k is larger than the array size
        k = k % n;
        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }
};

Here is a concise write-up for your cheat sheet. This format focuses on the "Why" and "How," which is exactly what interviewers look for.
Algorithm: One-Pass Greedy (Best Time to Buy & Sell Stock)
The Problem

Find the maximum difference between two numbers in an array (prices[j]‚àíprices[i]) such that j>i. If no profit is possible, return 0.
The Logic

Instead of comparing every pair (O(n2)), we maintain a running minimum. As we iterate, we treat every element as a potential selling day and calculate the profit against the lowest price seen before it.
Pseudocode

    Initialize min_price to infinity (or prices[0]) and max_profit to 0.

    Iterate through each price in the array:

        Update min_price: min_price = min(min_price, price)

        Update max_profit: max_profit = max(max_profit, price - min_price)

    Return max_profit.

Complexity

    Time: O(n) ‚Äî We visit each element exactly once.

    Space: O(1) ‚Äî We only store two integer variables regardless of input size.

Code Snippet (C++)
C++

int maxProfit(vector<int>& prices) {
    int minPrice = INT_MAX; 
    int maxProfit = 0;
    
    for (int price : prices) {
        if (price < minPrice) {
            minPrice = price; // Update the "valley"
        } else if (price - minPrice > maxProfit) {
            maxProfit = price - minPrice; // Update the "peak" profit
        }
    }
    return maxProfit;
}

Key Takeaway

    "Buy at the lowest valley seen so far; sell at the highest peak found after that valley."

Algorithm: Greedy BFS / Level-by-Level (Jump Game II)
The Logic

Imagine you are at your current position. You look at all the spots you can reach in exactly one jump. This is your "current window." From all those spots, you find the one that can launch you the farthest. Once you reach the end of your current window, you must take another jump, and your "window" moves to that new farthest point.
The 3 Key Variables

    jumps: The total number of jumps taken (the answer).

    currentEnd: The farthest we can go with our current number of jumps. (The end of the current window).

    farthest: The farthest point we can reach with one more jump.

Pseudocode

    Initialize jumps = 0, currentEnd = 0, farthest = 0.

    Loop through the array (up to the second-to-last element):

        Update farthest = max(farthest, i + nums[i]).

        If we reach currentEnd (the edge of our current jump's range):

            Increment jumps.

            Update currentEnd = farthest (move the window to the new horizon).

    Return jumps.

Complexity

    Time: O(n) ‚Äî Single pass.

    Space: O(1) ‚Äî Only three variables.

Code Snippet (C++)
C++

int jump(vector<int>& nums) {
    int jumps = 0, currentEnd = 0, farthest = 0;
    
    // We don't need to jump from the last element, so stop at size() - 1
    for (int i = 0; i < nums.size() - 1; i++) {
        farthest = max(farthest, i + nums[i]);
        
        // If we've reached the end of our current reach...
        if (i == currentEnd) {
            jumps++;             // We MUST jump
            currentEnd = farthest; // New boundary is the best we saw in the last window
        }
    }
    return jumps;
}
