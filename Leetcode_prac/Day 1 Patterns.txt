Day 1 Patterns: 

1. The "Filter" (Fast & Slow)

Pattern: One pointer scans (i), one pointer writes (k). Problem: Move Zeroes
C++

void moveZeroes(vector<int>& nums) {
    int k = 0; // The Write Pointer
    
    // Step 1: Filter non-zeroes to the front
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 0) {
            nums[k] = nums[i];
            k++;
        }
    }
    
    // Step 2: Fill the remaining "tail" with zeroes
    while (k < nums.size()) {
        nums[k] = 0;
        k++;
    }
}

2. The "De-Duplicator" (Look-Back)

Pattern: Compare the current element to what was written N steps ago. Problem: Remove Duplicates (Allowing at most 2)
C++

int removeDuplicates(vector<int>& nums) {
    if (nums.size() <= 2) return nums.size();

    int k = 2; // Start at 2 because first two are always "safe"
    for (int i = 2; i < nums.size(); i++) {
        // Look back 2 spots from where we are writing
        if (nums[i] != nums[k - 2]) {
            nums[k] = nums[i];
            k++;
        }
    }
    return k;
}

3. The "Swapper" (Opposite Ends)

Pattern: Pointers start at edges and "meet in the middle." Problem: Reverse a String
C++

void reverseString(vector<char>& s) {
    int left = 0;
    int right = s.size() - 1;

    while (left < right) {
        // Standard swap
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;

        // Move inward
        left++;
        right--;
    }
}

This is a great addition because it marks your transition from Two-Pointer patterns to Greedy/Voting patterns.

Here is the updated section for your printable cheat sheet. I‚Äôve titled this one "The King of the Hill" pattern to help the logic stick.
4. The Voting Pattern (Boyer-Moore)

Scenario: Finding an element that appears more than half the time (>n/2). Key Insight: If you pair up different elements and "cancel" them out, the majority element is guaranteed to be the one left over.
üìù The C++ Template
C++

int majorityElement(vector<int>& nums) {
    int candidate = 0;
    int count = 0;

    for (int x : nums) {
        // Phase 1: If power is depleted, pick a new candidate
        if (count == 0) {
            candidate = x;
        }

        // Phase 2: Update the candidate's power (count)
        if (x == candidate) {
            count++; // Same army: gain power
        } else {
            count--; // Enemy army: both lose 1 solider
        }
    }

    return candidate; // The "last soldier standing"
}

‚ö†Ô∏è Common Pitfall: Variable Shadowing

In an interview, do not write int candidate = x; inside the if block.

    Bad: if (count == 0) { int candidate = x; } (Creates a temporary variable that vanishes).

    Good: if (count == 0) { candidate = x; } (Updates the variable you created at the top).

How to use these templates:

    Identify the goal: Am I removing things? (Filter). Am I reordering? (Swapper). Am I cleaning a sorted list? (De-Duplicator).

    Sketch the pointers: On paper, draw i and k (or left and right).

    Check the "Stop" condition: Is it when the loop ends (i < size) or when pointers meet (left < right)?
